var sporadic=function(e){"use strict";var s={defer:()=>{const e={},s={changed:!1};return s.promise=new Promise((s,t)=>{e.resolve=s,e.reject=t}),s.resolve=(t=>{s.changed||(s.changed=!0,e.resolve(t))}),s.reject=(t=>{s.changed||(s.changed=!0,e.reject(t))}),s},resolved:e=>new Promise(s=>s(e)),rejected:e=>new Promise((s,t)=>t(e)),ignorePromise:e=>e.then(()=>!0).catch(()=>!0)};let t=null;t=(e=>{const{promise:r,resolve:o,reject:n}=s.defer(),a=r.then(()=>t(e));return{current:r,next:a,resolve:o,reject:n,produced:!1,broken:!1,finalizer:e}});const r=e=>s.resolved(t(e)),o=async e=>{return{current:await e.current,next:await e.next}},n=async e=>{let s=e;for(;s.produced&&!s.broken;)s=await s.next;return{point:s}},a=async(e,s)=>{const{point:t}=await n(e);return t.resolve(s),t.produced=!0,await t.next},i=async e=>{const{point:s}=await n(e);if(s.broken)await s.next;else{s.reject((()=>Error("Stream is closed!"))()),s.produced=!0,s.broken=!0;try{s.finalizer&&s.finalizer()}catch(e){}await s.next}},l=e=>i(e).catch(()=>{}),d=async(e,t)=>{const r=s.defer();let n=e;try{for(;;){const e=await o(n);n=e.next;try{await t(e.current)}catch(e){throw r.reject(e),e}}}catch(e){r.resolve(!0)}return await r.promise};var c={open:r,push:a,pull:o,close:i,react:d,filter:async(e,s)=>{const r=t();let o=r;return d(e,e=>{try{s(e)&&a(o,e).then(e=>{o=e}).catch(e=>{l(o)})}catch(e){l(o)}}).then(()=>{l(o)}),r},map:async(e,s)=>{const r=t();let o=r;return d(e,e=>{try{a(o,s(e)).then(e=>{o=e}).catch(e=>{l(o)})}catch(e){l(o)}}).then(()=>{l(o)}),r},every:e=>{let r=null;const o=t(()=>r());let n=o;const i=setInterval(()=>{a(n,!0).then(e=>{n=e})},e);return r=(()=>{clearInterval(i)}),s.resolved(o)},merge:async(e,s)=>{const t=await r();let o=t;const n=async e=>{o=await a(o,e)},l=d(e,n),c=d(s,n);return Promise.all([l,c]).then(()=>i(o).catch(function(){})),t}};const u=()=>Error("Channel is closed!");let p=null,m=null;var h={open:()=>s.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=s.defer(),e.isClosed=!1,e})()),send:p=((e,t,r)=>{if(0===e.demands.length){if(e.isClosed)return s.rejected(u());const o=s.defer();return null!=r&&"number"==typeof r&&r>=1&&setTimeout(()=>{o.resolve(!1)},Math.floor(r)),e.supplies.push({received:o,message:t}),o.promise}{let r=e.demands.shift();for(;e.demands.length>0&&r.changed;)r=e.demands.shift();return r.changed?p(e,t):(r.resolve(t),s.resolved(!0))}}),receive:m=((e,t)=>{if(0===e.supplies.length){if(e.isClosed)return s.rejected(u());const r=s.defer();return e.demands.push(r),null!=t&&"number"==typeof t&&t>=0&&setTimeout(()=>{r.reject((()=>Error("Timeout while listening channel!"))())},Math.floor(t)),r.promise}{let r=e.supplies.shift();for(;e.supplies.length>0&&r.received.changed;)r=e.supplies.shift();return r.received.changed?m(e,t):(r.received.resolve(!0),s.resolved(r.message))}}),close:e=>e.isClosed?s.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(u())})(e),e.closed.resolve(!0),s.resolved(!0)),closed:e=>e.closed.promise,sendAfter:(e,s,t,r)=>new Promise((o,n)=>{setTimeout(()=>{p(s,t,r).then(o,n)},Math.floor(Math.max(0,e)))}),receiveAfter:(e,s,t)=>new Promise((r,o)=>{setTimeout(()=>{m(s,t).then(r,o)},Math.floor(Math.max(0,e)))})};const f=1,v=2,w=3,E=4,y=["<undefined>","CREATED","RUNNING","SUSPENDED","DEAD"],M={PERSIST:1,COLLECT:2,DISABLE:3},g=async e=>(e.computation=!0,await s.ignorePromise(h.close(e.supply)),await s.ignorePromise(h.close(e.demand)),e.options.streamsMode!==M.DISABLE&&(await s.ignorePromise(c.close(e.demands)),await s.ignorePromise(c.close(e.supplies))),!0),C=e=>{const s=e.options&&e.options.streamsMode===M.DISABLE&&!e.supplies&&!e.demands,t=e.options&&(e.options.streamsMode===M.PERSIST||e.options.streamsMode===M.COLLECT)&&e.supplies&&e.demands,r=s||t;if(!(e&&e.status&&e.computation&&e.supply&&e.options&&e.demand&&r&&e.result&&e.result.promise instanceof Promise))throw Error("Expected a valid coroutine!")};let L=null,S=null,I=null,P=null,T=null,D=null,A=null;L=(async(e,t)=>{const r={},o=t||{};(e=>{if(!e||"DISABLE"!==e.streamsMode&&"COLLECT"!==e.streamsMode&&"PERSIST"!==e.streamsMode&&void 0!==e.streamsMode&&null!==e.streamsMode)throw Error(`Invalid coroutine configuration options.streamsMode: ${e.streamsMode}`)})(o),o.streamsMode=o.streamsMode||"PERSIST",o.streamsMode=M[o.streamsMode],o.streamsMode!==M.DISABLE&&(r.supplies=await c.open(),r.demands=await c.open()),r.options=o,r.supply=await h.open(),r.demand=await h.open(),r.computation=e,r.status=f,r.result=s.defer();const n={suspend:e=>S(r,e),status:()=>P(r),supplies:()=>D(r),demands:()=>T(r)};return r.computation=e.bind(n),r}),I=(async(e,s)=>{if(C(e),e.status===v)throw Error("Coroutine is already running!");if(e.status===E)throw Error("Coroutine is dead!");if(e.options.streamsMode!==M.DISABLE){const t=await c.push(e.demands,s);e.options.streamsMode===M.COLLECT&&(e.demands=t)}e.status===f?(e.status=v,e.computation(s).then(async s=>{if(e.options.streamsMode!==M.DISABLE){const t=await c.push(e.supplies,s);e.options.streamsMode===M.COLLECT&&(e.supplies=t)}h.send(e.supply,{value:s,type:"return"}),e.result.resolve(s)}).catch(s=>{h.send(e.supply,{value:s,type:"error"}),e.result.reject(s)})):(e.status=v,h.send(e.demand,s));const t=await h.receive(e.supply);if("error"===t.type)throw e.status=E,g(e),t.value;return"return"===t.type&&(e.status=E,g(e)),t.value}),S=(async(e,s)=>{if(e.status!==v)throw Error("Expected an active coroutine to yield from!");e.status=w;const t={value:s,type:"suspend"};if(e.options.streamsMode!==M.DISABLE){const t=await c.push(e.supplies,s);e.options.streamsMode===M.COLLECT&&(e.supplies=t)}return await h.send(e.supply,t),await h.receive(e.demand)});var j=c,x=h,B={create:L,resume:I,status:P=(e=>(C(e),y[e.status])),supplies:D=(e=>{if(C(e),e.options.streamsMode===M.DISABLE)throw Error("Coroutine created without supplies/demands streams!");return e.supplies}),demands:T=(e=>{if(C(e),e.options.streamsMode===M.DISABLE)throw Error("Coroutine created without supplies/demands streams!");return e.demands}),complete:A=(e=>(C(e),e.result.promise))},b={streams:j,channels:x,coroutines:B};return e.channels=x,e.coroutines=B,e.default=b,e.streams=j,e}({});